Qlik Sense

General Concepts,
Qlik Sense majorly works under the concept of association. 
Association is a soft join as opposed to SQL hard join. 

Qlik Sense uses soft join on fly based on user selections.

Generally Qlik Sense associates tables with a common field.
Synthetic key get created when there are more than one common field exist between tables
Qlik sense on itself try to resolve this synthetic table issue, By creating a seperate table with only those common fields 
Synthetic key always slow down and have a huge impact on performance.

There are various way to resolve synthetic key issues
By removing or renaming the common field from any of the table
By using qualify statement
By using link table, Which is also like a synthetic table but here you will have control on it. This is one of the option especially when you have tables with 
different levels of granularity. Composite key gets created to map all the associated tables and link table.

Circular Reference,
By default in qlik sense, inorder to avoid circular reference it will remove the large table from the association
but this is not a good practice, so data modeler has to take care of it.

Qlik sense supports Smart search, Expression search. 
Smart search not only brings textual values that matches, But also, filters the chart that contains those keywords to.
Expression search always starts with equal or greater than equal or less than equal sign.

There are different types of selection states, In dropdown, 
Green color values means currently selected values. 
white color values means associated values to current selection. 
Light grey color values means possible values.
Dark grey color values means excluded values from the current selection. 
These selection states that we can clearly see in dropdown.

Popular schema design,
Star schema and Snowflake schema. 
Star schema, center of this schema there is a fact table and at the end points of the star shape will have dimension tables. Fact table, It is usually one of the 
main table central to your application. Dimension table, tables provide master information about the dimensions provided in the fact table.
Snowflake schema resembles same like star schema but dimension table data itself splits down to additional dimension tables. Due to this multiple joins, this schema 
will have a more complex query than star schema. 

Popular Qlik Supported Features, 
Stories is essentially for showcasing or sharing your insights with other peoples within your organization. 
Bookmarks are created to save specific selection state.

What charts to use and when ?
When looking to compare discrete values, Use bar chart.
When looking to compare values that are time based, Use line chart. 
When looking at distribution, Use scatter plot or histogram. 
When looking at relationship, Use scatter plot.
When looking at composition or market share of a product, then use pie chart.
When looking at hierarchical relationship among various dimensions, then use treemap.

Useful information to find in data model viewer,
Information Density tells you, the percentage of non null values in a given field.
Subset Ratio tells you, the no of distinct values for a given field in a table compared to the total no of distinct values for the same field in the entire data model.
Generally dimension or master table will have subset ratio of 100%

Set Analysis,
Set analysis works only within an aggregation function. 
Set analysis always enclosed in curly braces.

Common things to remember in set analysis,
String values should be enclosed with single quotes.
Expression search should be with double quotes.

There are various identifiers used in set analysis,
$ (Default), Respects current selection.
$1, Represents the records of the previous selection.
$2, Represents the records of 2 selections back.
$_1, Represents the records of the forward selection.
$_2, Represents the records of 2 selections next.
1, Ignores user selection but not chart dimensions.

Total qualifier,
Total qualifier ignores the chart dimension and there is also an option to include specific dimensions

Popular chart and script functions,
Aggr function works exactly like SQL group by.
It creates a virtual table with grouped by dimensions and actual computed measure.

FieldValue takes two parameters, name of the field and position number.
Other than string value, explicit typecasting is required before using it anywhere.
In qlik sense, fields stores only distinct values. 

FieldValueCount is an integer function that finds the number of distinct values in a field.

Class function helps to bucket the measure to a range.

IntervalMatch is used to simulate between clause in SQL

FirstSortedValue, It is just opposite to aggr function. 
It takes dimension, expression and position number (optional). 
Returns the associated dimension for the given expression. 

Pick & Match is highly preferred inplace of using nested if statements.

Peek vs Previous
Both functions used to serve the same purpose, that is to do any manipulation with using previously loaded data.
One minor difference in which is, 
Previous works only on the input data, which means, while only loading the load from data source.
But Peek will work on both input and transformed data, but in case of error it will fail silently.

Let vs Set,
Variables can either be defined as Let or Set. 
Let evaluates the right hand expression first and then it stores to a variable
Set simply stored as a static string.

Use variables as function, 
We can use variables as function in qlik sense 
By using these special identifiers $1, $2 to get the first, second passed arguments of your function, 
Even in edgeverve we have created such variable, vScaleMoney.
The parameter $0 returns the number of parameters actually passed by a call.

Difference between include and must_include
include will silently fail and pass to next line if that particular requested file was not present
must_include will error out if that particular requested file was not present

In load statement
Where exist allows us to compare a field with any of the existing field 

Master Calendar
Qlik Sense usually stores data as dual values, both in string and numeric data.
It uses string format for just display purposes and numeric is for calculation.

Autogenerate X, Here X is an integer. 
This above line specifies the number of rows to be generated in the newly loading table.
All load statement requires some sort of source table but in case of autogenerate there is no need to give any source table because by itself, it will create a new 
table with X number of rows in it.

-1 is considered as True and 0 is considered as False in Qlik Sense.

Data manager option is a intuitive self service ETL tool for those who don't know how to write script.

In data load editor, Having multiple load statements inside a single table statement would still work.
As we all know inside each table statement, Qlik sense would execute things from bottom to top.

Table Name:
Load Statement
Load Statement
Select * from Table

Kind of doing transformation on top of already transformed data.
This is an simple example of preceding load.

Mapping Load always has two fields, key and value
To retrieve value from mapping table, Use apply map function. 

Cross Table is used to pivot the table.
Preceding load on a crosstable prefix will ignore qualifier fields and only include attribute fields.
Qualifier fields means the fields which are already in consumption state.

Implicit Concatenation
If you have two tables with the same number of fields and same name of fields
Then qlik sense will perform an implicit concatenation 
Unless you provide no concatenate operator before you load the second table.
Even with giving different name to second table it is of no use without no concatenate operator.

Forced Concatenation
You can concatenate any two tables with using concatenate operator.

What happens when there are no common fields while using explicit Inner Join Statment between two tables in Qlik Sense?
Qlik Sense generates a cartesian product.

QVD is a binary data file. Qlik used to read and write data to QVD.
10 to 100 times faster than data load from a database.
Reduced load on the database.
With QVD, You can perform incremental load.

QVD Load will be optimized when we follow these rules
No major transformations have been done in load statement
Only allowed to alias fields
Only allowed to use where exists clause, with just one parameter

Qlik Sense Architecture is composed of three layers
Data access layer, application layer, presentation layer

Data Access layer contains various data source systems to connect. 
Application layer contains QMC where it will have these services
Proxy responsible for routing the users request to appropriate place
Engine service responsible for all in memory calculations and self service interactions
Scheduler responsible for reloading the app data
Repository responsible for storing all app related information such as security and many more
Then comes the Presentation layer for the designer to create visualizations.

Whenever user make any selection, then the entire data model will get recalculated based on that selection.
Inorder to avoid any such unnecessary recomputation on million & million of records, you can add calculation condition which will help us to show some simple message 
to user of asking to select within that limit.

Qlik Associative Engine contains 7 core components,
QIX internal database which contains symbol & data table
Inference engine
Calculation engine
Few others

Every time when user make selection, Colors and states for each field is recalculated by the logical inference engine. Then this is passed to the calculation engine. 
By which, charts expressions are recalculated. When calculation involve fields from two different tables, Temporary table is being created for the calculation. 
This is a single threaded process and thus impacts performance.

Generally symbol data will store only has the unique values of the field and the associated binary index. Whereas data table simply referencing the binary index 
rather than the actual value.

Development best practices,
Split high cardinality fields (having more no of unique values)
Use integers to associate or join tables whenever possible, Since integers doesn't require symbol space whereas alphanumeric keys do.

Design best practices,
Avoid using if statements in chart expression, it is a single threaded.
Avoid using aggr function in calculated dimension as it is resource intensive.

Incremental Load Steps,
Create QVD with initial data
Store maximum value of primary key field into seperate QVD
From next load, fetch the max value from QVD and use that in where clause to discriminate new and old records.
Get initial data from QVD and concatenate the new records with to it.

Common tip,
Always try to use field based function instead of table based function. Because generally in qlik sense fields are stored in symbol tables which is used to store only
the unique values. So it is relatively faster compared to table based operations like resident load.

Alternate States,
By default selections made in one state will not affect the selections made in other state.
With set analysis, You can completely control the various states. Like it even allows to pass selections across states.
Syntax would be little different from rest of it.

Authentication & Authorization,
Authentication is a process of validating user's identity and Authorization is a process of granting or denying users access to resources. 
Qlik proxy service handles authentication. Once user gets identified then proxy service create session cookie and passes the information to the Qlik repository 
service which then uses rules to handle authorization. After all check, Finally it passes information to Qlik sense engine service.

Securities, All these below securities can be achieved by attaching some custom property to either stream or app resources.
Then in security rule, Using that custom property to compare it with your logged in user attribute.

Stream level access, App level access, Sheet level access.

On demand app generation
It is useful for visualizing large and most frequently changing data sets.
Generally we will all start to explore with some source application, Then with the help of ODAG extension, dynamically we will be creating one new app from the 
user's selected data.

Useful things to review once in udemy
Set Analysis, FirstSortedValue, Peek Function, Cross Table 
Advanced Qlik Sense Masterclass - Advanced Set Analysis - Important Operators (Very helpful)
Sum({$<SALESPERSON = {'JOHN DOE'}>}SALES)	 |
							 
Sum({<YEAR = {"2*", "198*"} - {"2000"}>} Sales)
Aggregates sales where year is starting with 2 or between 1980 - 1989
But should not be 2000

Sum({<YEAR = {">=2001"}>} Sales)
Aggregates sales where year is above 2000

Group by
Sum({<SALES_MAN = {"=Rank(Sum(salary)) <= 3"}>} Sales) or
Sum({<SALES_MAN = {"=Aggr(Rank(Sum(salary)), SALES_MAN) <= 3"}>} Sales)
Aggregates sales of top 3 earning salesperson

Sum({<SALES_MAN = {"=Rank(Sum(salary)) <= 3"}, YEAR = {">=2001"}>} Sales)
Whichever get suceeds in either one or both the criteria will be considered for aggregation
Aggregates sales of top 3 earning salerperson 
Aggregates sales where year is above 2000

Sum({<SALES_MAN = {"=Rank(Sum(salary)) <= 3"}> * <YEAR = {">=2001"}>} Sales)
Here whichever get suceeds in both the criteria only will be considered for aggregation
Aggregates sales of top 3 earning salerperson 
Aggregates sales where year is above 2000

Count({<ProductID = >} Product)	
Exclude ProductId Selection.

Symbol & Data Table,

								Symbol Table
							   	------------------------
								Country		Pointers
							   	------------------------
								India		000	
								Pakistan	001	
								Srilanka	010	
								Bangladesh	011	
								Nepal		100
								China		101

								
								Symbol Table
							   	------------------------
								Country		Pointers
							   	------------------------
								India		000	
								Pakistan	001	
								Srilanka	010	
								Bangladesh	011	
								Nepal		100
								China		101
								

								Data Table
							   	---------------------
							   	Country		Sales
							   	---------------------
							   	000		00
							   	001		01
							   	010		10
							   	011		11
							   	100
							   	101
							   
Categorical types of data

Nominal 	- Like employee names - Doesn't have any order			
Ordinal 	- Nice, Hot, Very Hot - Ordered but difficult to measure difference			
Interval	- 60 - 70	
Ratio		- 70%
							
