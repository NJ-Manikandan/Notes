def simple(b, a = 10):
    a = a + b; print(a)
    
simple(1); simple(2); simple(3)
output: 
11 
12 
13

def simple(b, a = []):
    a.append(b); print(a)
    
simple(1); simple(2); simple(3)
output: 
[1]
[1, 2]
[1, 2, 3]

Amortized time is the way to express the time complexity when an algorithm has the very bad time complexity only once in a while besides the time complexity that happens most of time. Good example would be an ArrayList which is a data structure that contains an array and can be extended

rec = {"Name" : "Python", "Age":"20", "Addr" : "NJ", "Country" : "USA"}
id1 = id(rec)
del rec
rec = {}
id2 = id(rec)
print(id1 == id2)
output:
True

reca = {"Name" : "Python", "Age":"20", "Addr" : "NJ", "Country" : "USA"}
id1 = id(reca)
del reca
recb = {}
id2 = id(recb)
print(id1 == id2)
output:
True

reca = {"Name" : "Python", "Age":"20", "Addr" : "NJ", "Country" : "USA"}
id1 = id(reca)
recb = {}
id2 = id(recb)  
print(id1 == id2)
output:
False

tuples = (1)
print(type(tuples))
output:
int

tuples = (1,)
print(type(tuples))
output:
tuple



The __getitem__ magic method is usually used for list indexing, dictionary lookup, or accessing ranges of values. Considering how versatile it is, it’s probably one of Python’s most underutilized magic methods.

seq = [[0,100],[5,10],[15,20]]
[x for x in sorted(seq, key = lambda x: x[1])]

class Solution(object):
    def letterCasePermutation(self, S):
        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x
        return map("".join, itertools.product(*map(f, S)))
		
Counter("mani")
# It will store like {"m": 1, "a": 1, "n": 1, "i": 1} but it is counter object